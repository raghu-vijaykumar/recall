<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BERTopic Knowledge Graph Visualizer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }

      .header {
        text-align: center;
        margin-bottom: 30px;
        color: white;
      }

      .header h1 {
        margin: 0 0 10px 0;
        font-size: 2.5em;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .header p {
        margin: 0;
        font-size: 1.1em;
        opacity: 0.9;
      }

      .visualization-container {
        background: white;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        padding: 20px;
        margin-bottom: 20px;
      }

      .controls {
        background: #f8f9fa;
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        align-items: center;
        justify-content: space-between;
      }

      .control-group {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .control-group label {
        font-weight: 600;
        color: #333;
      }

      .control-group select,
      .control-group input {
        padding: 8px 12px;
        border: 1px solid #ddd;
        border-radius: 5px;
        font-size: 14px;
      }

      .stats {
        display: flex;
        gap: 30px;
        color: #666;
        font-size: 14px;
      }

      .legend {
        display: flex;
        gap: 20px;
        align-items: center;
        flex-wrap: wrap;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 5px;
        font-size: 12px;
      }

      .legend-color {
        width: 15px;
        height: 15px;
        border-radius: 50%;
      }

      svg {
        border-radius: 10px;
        background: radial-gradient(circle at center, #f8f9fa 0%, #e9ecef 100%);
      }

      .node {
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .node:hover {
        stroke-width: 3px;
        stroke: #333;
      }

      .node.selected {
        stroke: #ff6b6b;
        stroke-width: 4px;
      }

      .link {
        stroke: #999;
        stroke-opacity: 0.6;
        transition: stroke-opacity 0.2s ease;
      }

      .link:hover {
        stroke-opacity: 1;
      }

      .tooltip {
        position: absolute;
        background: rgba(255, 255, 255, 0.95);
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        pointer-events: none;
        max-width: 300px;
        font-size: 12px;
        z-index: 1000;
        backdrop-filter: blur(10px);
      }

      .tooltip h4 {
        margin: 0 0 8px 0;
        color: #333;
        font-size: 14px;
      }

      .tooltip p {
        margin: 4px 0;
        line-height: 1.3;
      }

      .tooltip .label {
        font-weight: bold;
        color: #666;
      }

      .search-container {
        margin-bottom: 10px;
      }

      .search-input {
        width: 100%;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 5px;
        font-size: 14px;
      }

      .loading {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.9);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        backdrop-filter: blur(5px);
      }

      .spinner {
        width: 50px;
        height: 50px;
        border: 4px solid #f3f3f3;
        border-top: 4px solid #3498db;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .info-panel {
        background: #f8f9fa;
        border-radius: 8px;
        padding: 15px;
        margin-top: 15px;
      }

      .info-panel h3 {
        margin: 0 0 10px 0;
        color: #333;
      }

      .highlight-words {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        margin-top: 5px;
      }

      .word-chip {
        background: #e3f2fd;
        color: #1976d2;
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 11px;
        font-weight: 500;
      }

      .zoom-controls {
        position: absolute;
        top: 20px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 5px;
      }

      .zoom-button {
        width: 30px;
        height: 30px;
        border: none;
        border-radius: 5px;
        background: rgba(255, 255, 255, 0.9);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        font-weight: bold;
        transition: all 0.2s ease;
      }

      .zoom-button:hover {
        background: white;
        transform: scale(1.05);
      }

      @media (max-width: 768px) {
        .container {
          padding: 10px;
        }
        .header h1 {
          font-size: 2em;
        }
        .controls {
          flex-direction: column;
          align-items: stretch;
        }
        .stats {
          justify-content: center;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>ðŸ§  BERTopic Knowledge Graph Explorer</h1>
        <p>Interactive visualization of topic clusters and relationships</p>
      </div>

      <div class="visualization-container">
        <div class="controls">
          <div class="control-group">
            <span style="color: #666; font-size: 12px"
              >Loading: Full Dataset (All topics)</span
            >
          </div>

          <div class="control-group">
            <label>Layout:</label>
            <select id="layoutSelect">
              <option value="force">Force Directed</option>
              <option value="radial">Radial</option>
              <option value="cluster">Hierarchical</option>
            </select>
          </div>

          <div class="control-group">
            <label>Node Size:</label>
            <select id="sizeSelect">
              <option value="fixed">Fixed</option>
              <option value="documents">By Document Count</option>
              <option value="connections">By Connections</option>
            </select>
          </div>

          <div class="control-group">
            <label>Filter:</label>
            <select id="filterSelect">
              <option value="all">All Nodes</option>
              <option value="topics">Topics Only</option>
              <option value="concepts">Concepts Only</option>
              <option value="documents">Documents Only</option>
            </select>
          </div>

          <div class="search-container">
            <input
              type="text"
              id="searchInput"
              class="search-input"
              placeholder="Search nodes..."
            />
          </div>

          <div class="legend">
            <div class="legend-item">
              <div class="legend-color" style="background: #ff6b6b"></div>
              <span>Topic</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background: #4ecdc4"></div>
              <span>Concept</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background: #45b7d1"></div>
              <span>Document</span>
            </div>
          </div>
        </div>

        <div class="stats">
          <span id="nodeCount">Nodes: 0</span>
          <span id="edgeCount">Edges: 0</span>
          <span id="selectedCount">Selected: 0</span>
        </div>

        <div id="graphContainer" style="position: relative">
          <div class="zoom-controls">
            <button class="zoom-button" id="zoomIn">+</button>
            <button class="zoom-button" id="zoomOut">âˆ’</button>
            <button class="zoom-button" id="resetZoom">â¤¢</button>
          </div>
          <svg id="graph"></svg>
        </div>

        <div class="info-panel" id="infoPanel" style="display: none">
          <h3 id="selectedTitle">Selected Node</h3>
          <p><strong>Type:</strong> <span id="selectedType"></span></p>
          <p><strong>Description:</strong> <span id="selectedDesc"></span></p>
          <div id="selectedMeta"></div>
          <div id="highlightWords" class="highlight-words"></div>
        </div>
      </div>
    </div>

    <div class="loading" id="loading" style="display: none">
      <div class="spinner"></div>
    </div>

    <div class="tooltip" id="tooltip" style="display: none"></div>

    <script>
      class KnowledgeGraphVisualizer {
        constructor() {
          this.svg = null;
          this.g = null;
          this.simulation = null;
          this.nodes = [];
          this.links = [];
          this.originalNodes = [];
          this.originalLinks = [];
          this.width = 1200;
          this.height = 800;
          this.selectedNode = null;
          this.searchTerm = "";
          this.currentLayout = "force";
          this.currentSize = "fixed";
          this.currentFilter = "all";

          this.colorMap = {
            topic: "#ff6b6b",
            concept: "#4ecdc4",
            document: "#45b7d1",
          };

          this.init();
        }

        init() {
          this.setupSVG();
          this.setupEventListeners();
          this.loadData();
        }

        setupSVG() {
          this.svg = d3
            .select("#graph")
            .attr("width", this.width)
            .attr("height", this.height);
          this.g = this.svg.append("g");
          const zoom = d3
            .zoom()
            .scaleExtent([0.1, 4])
            .on("zoom", (event) => {
              this.g.attr("transform", event.transform);
            });
          this.svg.call(zoom);
        }

        setupEventListeners() {
          d3.select("#layoutSelect").on("change", () => {
            this.currentLayout = d3.select("#layoutSelect").property("value");
            this.updateLayout();
          });

          d3.select("#sizeSelect").on("change", () => {
            this.currentSize = d3.select("#sizeSelect").property("value");
            this.updateNodeSizes();
          });

          d3.select("#filterSelect").on("change", () => {
            this.currentFilter = d3.select("#filterSelect").property("value");
            this.applyFilter();
          });

          d3.select("#searchInput").on("input", () => {
            this.searchTerm = d3
              .select("#searchInput")
              .property("value")
              .toLowerCase();
            this.applySearch();
          });

          d3.select("#zoomIn").on("click", () => this.zoomIn());
          d3.select("#zoomOut").on("click", () => this.zoomOut());
          d3.select("#resetZoom").on("click", () => this.resetZoom());
        }

        loadData() {
          try {
            d3.select("#loading").style("display", "flex");

            const fileName =
              "./results/multilinguale5base_docs/visualization_data.json";

            fetch(fileName)
              .then((response) => {
                if (!response.ok)
                  throw new Error(
                    `HTTP ${response.status}: ${response.statusText}`
                  );
                return response.json();
              })
              .then((data) => {
                // Validate and filter data
                this.originalNodes = (data.nodes || []).filter(
                  (node) => node && node.id && node.label && node.type
                );

                // Create a set of valid node IDs for quick lookup
                const validNodeIds = new Set(
                  this.originalNodes.map((n) => n.id)
                );

                // Filter edges to only include those where both source and target nodes exist
                this.originalLinks = (data.edges || [])
                  .filter(
                    (edge) =>
                      edge &&
                      edge.source &&
                      edge.target &&
                      validNodeIds.has(
                        typeof edge.source === "object"
                          ? edge.source.id || edge.source
                          : edge.source
                      ) &&
                      validNodeIds.has(
                        typeof edge.target === "object"
                          ? edge.target.id || edge.target
                          : edge.target
                      )
                  )
                  .map((edge) => ({
                    source:
                      typeof edge.source === "object"
                        ? edge.source.id || edge.source
                        : edge.source,
                    target:
                      typeof edge.target === "object"
                        ? edge.target.id || edge.target
                        : edge.target,
                    weight: edge.weight || 1,
                  }));

                console.log(
                  `Loaded ${this.originalNodes.length} nodes and ${this.originalLinks.length} edges (filtered ${(data.edges || []).length - this.originalLinks.length} invalid edges)`
                );
                this.processData();
                this.render();
                d3.select("#loading").style("display", "none");
              })
              .catch((error) => {
                console.error("Error loading data:", error);
                d3.select("#loading").style("display", "none");
                alert("Error loading data: " + error.message);
              });
          } catch (error) {
            console.error("Error:", error);
            d3.select("#loading").style("display", "none");
          }
        }

        processData() {
          this.nodes = this.originalNodes.map((node) => ({
            ...node,
            x: Math.random() * this.width,
            y: Math.random() * this.height,
            vx: 0,
            vy: 0,
          }));

          this.links = this.originalLinks.map((link) => ({
            ...link,
            source: link.source,
            target: link.target,
            strength: link.weight || 1,
          }));

          this.updateStats();
        }

        updateStats() {
          d3.select("#nodeCount").text(`Nodes: ${this.nodes.length}`);
          d3.select("#edgeCount").text(`Edges: ${this.links.length}`);
          d3.select("#selectedCount").text(
            `Selected: ${this.selectedNode ? 1 : 0}`
          );
        }

        updateNodeSizes() {
          this.g.selectAll(".node").attr("r", (d) => {
            switch (this.currentSize) {
              case "documents":
                return d.metadata?.document_count
                  ? Math.sqrt(d.metadata.document_count) + 5
                  : 8;
              case "connections":
                const connections = this.links.filter(
                  (l) => l.source.id === d.id || l.target.id === d.id
                ).length;
                return Math.sqrt(connections) * 2 + 5;
              default:
                return 8;
            }
          });
        }

        applyFilter() {
          let filteredNodes = [...this.originalNodes];
          switch (this.currentFilter) {
            case "topics":
              filteredNodes = this.originalNodes.filter(
                (n) => n.type === "topic"
              );
              break;
            case "concepts":
              filteredNodes = this.originalNodes.filter(
                (n) => n.type === "concept"
              );
              break;
            case "documents":
              filteredNodes = this.originalNodes.filter(
                (n) => n.type === "document"
              );
              break;
          }

          const filteredIds = new Set(filteredNodes.map((n) => n.id));
          const filteredLinks = this.originalLinks.filter(
            (l) => filteredIds.has(l.source) && filteredIds.has(l.target)
          );

          this.nodes = filteredNodes.map((node) => ({
            ...node,
            x: Math.random() * this.width,
            y: Math.random() * this.height,
            vx: 0,
            vy: 0,
          }));
          this.links = filteredLinks.map((link) => ({
            ...link,
            source: link.source,
            target: link.target,
          }));
          this.updateStats();
          this.render();
        }

        applySearch() {
          if (!this.searchTerm) {
            this.applyFilter();
            return;
          }

          let filteredNodes = this.originalNodes.filter(
            (node) =>
              node.label?.toLowerCase().includes(this.searchTerm) ||
              node.type?.toLowerCase().includes(this.searchTerm) ||
              node.metadata?.top_words?.some((word) =>
                word.toLowerCase().includes(this.searchTerm)
              )
          );

          const filteredIds = new Set(filteredNodes.map((n) => n.id));
          this.originalLinks.forEach((link) => {
            if (filteredIds.has(link.source) && !filteredIds.has(link.target)) {
              const target = this.originalNodes.find(
                (n) => n.id === link.target
              );
              if (target) filteredNodes.push(target);
            }
            if (filteredIds.has(link.target) && !filteredIds.has(link.source)) {
              const source = this.originalNodes.find(
                (n) => n.id === link.source
              );
              if (source) filteredNodes.push(source);
            }
          });

          filteredNodes = [
            ...new Map(filteredNodes.map((n) => [n.id, n])).values(),
          ];
          const filteredLinks = this.originalLinks.filter(
            (l) => filteredIds.has(l.source) && filteredIds.has(l.target)
          );

          this.nodes = filteredNodes.map((node) => ({
            ...node,
            x: Math.random() * this.width,
            y: Math.random() * this.height,
            vx: 0,
            vy: 0,
          }));
          this.links = filteredLinks.map((link) => ({
            ...link,
            source: link.source,
            target: link.target,
          }));
          this.updateStats();
          this.render();
        }

        updateLayout() {
          if (this.simulation) this.simulation.stop();
          switch (this.currentLayout) {
            case "radial":
              this.applyRadialLayout();
              break;
            case "cluster":
              this.applyClusterLayout();
              break;
            default:
              this.applyForceLayout();
              break;
          }
        }

        applyForceLayout() {
          this.simulation = d3
            .forceSimulation(this.nodes)
            .force(
              "link",
              d3
                .forceLink(this.links)
                .id((d) => d.id)
                .distance((d) => 50 + (1 - d.strength) * 50)
            )
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(this.width / 2, this.height / 2))
            .force(
              "collision",
              d3.forceCollide((d) => this.getNodeSize(d) + 10)
            );

          this.simulation.on("tick", () => {
            this.g
              .selectAll(".link")
              .attr("x1", (d) => d.source.x)
              .attr("y1", (d) => d.source.y)
              .attr("x2", (d) => d.target.x)
              .attr("y2", (d) => d.target.y);
            this.g
              .selectAll(".node")
              .attr("cx", (d) => d.x)
              .attr("cy", (d) => d.y);
          });
        }

        applyRadialLayout() {
          const groups = d3.groups(this.nodes, (d) => d.type);
          groups.forEach(([type, groupNodes], groupIndex) => {
            const groupRadius =
              (Math.min(this.width, this.height) / 3) * (groupIndex + 1);
            const angleStep = (2 * Math.PI) / groupNodes.length;
            groupNodes.forEach((node, i) => {
              node.x = this.width / 2 + groupRadius * Math.cos(i * angleStep);
              node.y = this.height / 2 + groupRadius * Math.sin(i * angleStep);
            });
          });
        }

        applyClusterLayout() {
          const rootNodes = this.nodes.filter((n) => n.type === "topic");
          const conceptNodes = this.nodes.filter((n) => n.type === "concept");
          const documentNodes = this.nodes.filter((n) => n.type === "document");

          const layoutWidth = this.width - 200;
          rootNodes.forEach((node, i) => {
            node.x = 100 + i * (layoutWidth / Math.max(rootNodes.length, 1));
            node.y = this.height / 2;
          });

          conceptNodes.forEach((node, i) => {
            node.x = this.width / 2 + ((i % 5) - 2) * 100;
            node.y = 100 + Math.floor(i / 5) * 100;
          });

          documentNodes.forEach((node, i) => {
            node.x = this.width - 100 - (i % 3) * 80;
            node.y = 100 + Math.floor(i / 3) * 80;
          });
        }

        render() {
          this.g.selectAll("*").remove();

          const linkElements = this.g
            .selectAll(".link")
            .data(this.links)
            .enter()
            .append("line")
            .attr("class", "link")
            .attr("stroke-width", (d) => Math.sqrt(d.strength) * 2 + 1);

          const nodeElements = this.g
            .selectAll(".node")
            .data(this.nodes)
            .enter()
            .append("circle")
            .attr("class", "node")
            .attr("r", (d) => {
              switch (this.currentSize) {
                case "documents":
                  return d.metadata?.document_count
                    ? Math.sqrt(d.metadata.document_count) + 5
                    : 8;
                case "connections":
                  const connections = this.links.filter(
                    (l) => l.source.id === d.id || l.target.id === d.id
                  ).length;
                  return Math.sqrt(connections) * 2 + 5;
                default:
                  return 8;
              }
            })
            .attr("fill", (d) => this.colorMap[d.type] || "#666")
            .attr("stroke", "#fff")
            .attr("stroke-width", 2)
            .on("mouseover", (event, d) => this.showTooltip(event, d))
            .on("mouseout", () => this.hideTooltip())
            .on("click", (event, d) => this.selectNode(d))
            .call(
              d3
                .drag()
                .on("start", (event, d) => {
                  if (!event.active && this.simulation)
                    this.simulation.alphaTarget(0.3).restart();
                  d.fx = d.x;
                  d.fy = d.y;
                })
                .on("drag", (event, d) => {
                  d.fx = event.x;
                  d.fy = event.y;
                })
                .on("end", (event, d) => {
                  if (!event.active && this.simulation)
                    this.simulation.alphaTarget(0);
                  d.fx = null;
                  d.fy = null;
                })
            );

          this.g
            .selectAll(".node-label")
            .data(this.nodes.filter((d) => d.type === "topic"))
            .enter()
            .append("text")
            .attr("class", "node-label")
            .attr("x", (d) => d.x)
            .attr("y", (d) => d.y - 15)
            .attr("text-anchor", "middle")
            .attr("font-size", "10px")
            .attr("font-weight", "bold")
            .attr("fill", "#333")
            .text((d) =>
              d.label.split("_").slice(1).join(" ").substring(0, 20)
            );

          this.updateLayout();
        }

        showTooltip(event, d) {
          const tooltip = d3
            .select("#tooltip")
            .style("display", "block")
            .style("left", event.pageX + 10 + "px")
            .style("top", event.pageY - 10 + "px");

          let content = `<h4>${d.label}</h4><p><span class="label">Type:</span> ${d.type}</p>`;
          if (d.metadata) {
            if (d.metadata.document_count)
              content += `<p><span class="label">Documents:</span> ${d.metadata.document_count}</p>`;
            if (d.metadata.topic_id !== undefined)
              content += `<p><span class="label">Topic ID:</span> ${d.metadata.topic_id}</p>`;
            if (d.metadata.top_words?.length)
              content += `<p><span class="label">Top words:</span> ${d.metadata.top_words.slice(0, 3).join(", ")}</p>`;
            if (d.metadata.coherence_score)
              content += `<p><span class="label">Coherence:</span> ${d.metadata.coherence_score.toFixed(4)}</p>`;
          }
          tooltip.html(content);
        }

        hideTooltip() {
          d3.select("#tooltip").style("display", "none");
        }

        selectNode(node) {
          d3.selectAll(".node").classed("selected", false);
          if (this.selectedNode !== node) {
            this.selectedNode = node;
            d3.selectAll(".node")
              .filter((d) => d.id === node.id)
              .classed("selected", true);
            this.showNodeInfo(node);
          } else {
            d3.select("#infoPanel").style("display", "none");
            this.selectedNode = null;
          }
          this.updateStats();
        }

        showNodeInfo(node) {
          const panel = d3.select("#infoPanel").style("display", "block");
          panel.select("#selectedTitle").text(node.label);
          panel.select("#selectedType").text(node.type);

          let description = "";
          if (node.metadata?.document_count)
            description += `${node.metadata.document_count} documents`;
          if (node.metadata?.top_words?.length)
            description += ` â€¢ Top words: ${node.metadata.top_words.slice(0, 5).join(", ")}`;

          panel
            .select("#selectedDesc")
            .text(description || "No additional information");

          const metaDiv = panel.select("#selectedMeta");
          metaDiv.html("");
          if (node.metadata) {
            Object.entries(node.metadata).forEach(([key, value]) => {
              if (!["top_words", "document_count", "topic_id"].includes(key)) {
                metaDiv
                  .append("p")
                  .html(
                    `<strong>${key}:</strong> ${typeof value === "object" ? JSON.stringify(value).substring(0, 100) : value}`
                  );
              }
            });
          }

          const wordsDiv = panel.select("#highlightWords");
          wordsDiv.html("");
          if (node.metadata?.top_words) {
            node.metadata.top_words.slice(0, 10).forEach((word) => {
              wordsDiv.append("span").attr("class", "word-chip").text(word);
            });
          }
        }

        getNodeSize(d) {
          switch (this.currentSize) {
            case "documents":
              return d.metadata?.document_count || 0;
            case "connections":
              return this.links.filter(
                (l) => l.source.id === d.id || l.target.id === d.id
              ).length;
            default:
              return 1;
          }
        }

        zoomIn() {
          this.svg.transition().duration(300).call(d3.zoom().scaleBy, 1.3);
        }
        zoomOut() {
          this.svg.transition().duration(300).call(d3.zoom().scaleBy, 0.7);
        }
        resetZoom() {
          this.svg
            .transition()
            .duration(500)
            .call(d3.zoom().transform, d3.zoomIdentity);
        }
      }

      document.addEventListener("DOMContentLoaded", () => {
        new KnowledgeGraphVisualizer();
      });
    </script>
  </body>
</html>
